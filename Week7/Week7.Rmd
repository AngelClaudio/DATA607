---
title: "Different Data Type Imports"
author: "Angel Claudio"
date: 
output:
  rmdformats::material:
    cards: true
---
# Setup

Main libraries to use are:

1. **rvest** for HTML Scraping
2. **XML** to deal with XML nodes
3. **jsonLite** to negotiate the JSON objects
4. **RCurl** to surpass any https limitation of other packages
5. **tidyverse** for piping

```{r setup, message=F, warning=F}
knitr::opts_chunk$set(echo = TRUE)
library(rvest)
library(tidyverse)
library(XML)
library(RCurl)
library(jsonlite)
```

# Three Data Source - Declarations

Here are the three data sources we will be using in three different formats:

1. HTML
2. XML
3. JSON

```{r declare-sources }
html_url <- "https://raw.githubusercontent.com/AngelClaudio/DataSources/master/Books.html"
xml_url <- "https://raw.githubusercontent.com/AngelClaudio/DataSources/master/Books.xml"
json_url <-"https://raw.githubusercontent.com/AngelClaudio/DataSources/master/Books.json" 
```

# Extract HTML Data

Leverage the **rvest** package for reading HTML, useful when needing intense HTML data scraping of nodes etc.

```{r extract-html}
(df_html_source <- read_html(html_url) %>% html_nodes("table") %>% html_table)
```

# Extract XML Data 

Leverage **RCurl** package for https resources and then use **XML** package to work with the xml structure.

When using the **xmlToDataFrame** function, we are using the **stringAsFactors** argument to prevent setting strings as factors, however we can easily in the last step (explained in section "Comparison of Data Frame") use the **convert** arument of **all_equal** function

```{r extract-xml}
(df_xml_source <- getURL(xml_url) %>% xmlParse %>% xmlToDataFrame(stringsAsFactors=F))
```


# Extract JSON Data 

JSON as usual is a delight to work with since it's an industry standard for RESTful calls.

```{r extract-json}
(df_json_source <- getURL(json_url) %>% fromJSON)
```

# Comparison of Data Frames

All Data Sources are 100% Identical as checked with **all_equal** function.

Note that from the extraction step, instead of using **stringsAsFactor=F** argument, we instead could have used the **convert=T** argument to match the secondary source data types with primary source in the **all_equal** function. It will essentially convert factor to character or integer to double, in our case we would have been interested in the former (example commented below).

[LINK: all_equal function reference with convert argument details](https://rdrr.io/cran/dplyr/man/all_equal.html) 

```{r comparison_dataframes}
(all_equal(df_html_source, df_json_source))
(all_equal(df_html_source, df_xml_source))
(all_equal(df_json_source, df_xml_source))
#all_equal(df_html_source, df_xml_source, convert=T) #OPTIONAL APPROACH
```

